package me.ht9.rose.feature.module.modules.exploit.newchunks;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.*;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.modules.render.fov.FOV;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.util.render.Render3d;
import me.ht9.rose.util.world.Vec2D;
import me.ht9.rose.mixin.accessors.EntityRendererAccessor;
import net.minecraft.src.*;
import org.lwjgl.opengl.GL11;

import java.util.Set;
import java.util.concurrent.CopyOnWriteArraySet;

@Description("Detects new chunks via physics (sand/gravel/water/lava) updates.")
public final class NewChunks extends Module
{
    private static final NewChunks instance = new NewChunks();

    private final Setting<Integer> y = new Setting<>("Y", 0, 0, 128);
    private final Setting<Boolean> liquids = new Setting<>("Liquids", true);
    private final Setting<Boolean> falling = new Setting<>("Falling", true);
    private final Setting<Boolean> remove = new Setting<>("Remove", false);
    private final Setting<Integer> removeDist = new Setting<>("RemoveDist", 100, 400, 5000, this.remove::value);

    private final Set<Vec2D> chunks = new CopyOnWriteArraySet<>();

    @Override
    public void onDisable()
    {
        chunks.clear();
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event)
    {
        if (event.packet() instanceof Packet53BlockChange packet)
        {
            if (mc.thePlayer.getDistanceSq(packet.xPosition, packet.yPosition, packet.zPosition) < 256) return;
            if (isNewChunk(mc.theWorld.getBlockId(packet.xPosition, packet.yPosition, packet.zPosition), packet.type))
                chunks.add(new Vec2D(packet.xPosition >> 4, packet.zPosition >> 4));
        } else if (event.packet() instanceof Packet52MultiBlockChange packet)
        {
            int chunkX = packet.xPosition << 4,
                    chunkZ = packet.zPosition << 4;
            for (int i = 0; i < packet.size; i++)
            {
                int x = chunkX + (packet.coordinateArray[i] >> 12 & 15),
                        y = packet.coordinateArray[i] & 255,
                        z = chunkZ + (packet.coordinateArray[i] >> 8 & 15);
                if (mc.thePlayer.getDistanceSq(x, y, z) < 256) continue;
                if (isNewChunk(mc.theWorld.getBlockId(x, y, z), packet.typeArray[i]))
                {
                    chunks.add(new Vec2D(packet.xPosition, packet.zPosition));
                    break;
                }
            }
        }
    }

    @SubscribeEvent
    public void onRender3d(RenderWorldPassEvent event)
    {
        if (chunks.isEmpty()) return;

        Render3d.render3d(() ->
        {
            ((EntityRendererAccessor) mc.entityRenderer).invokeSetupCameraTransform(event.partialTicks(), 0);

            GL11.glMatrixMode(GL11.GL_PROJECTION);
            GL11.glLoadIdentity();
            /*
            @TODO add better fov method
             */
            float fov = FOV.instance().fov.value();
            float aspect = (float) mc.displayWidth / (float) mc.displayHeight;
            org.lwjgl.util.glu.GLU.gluPerspective(fov, aspect, 0.05f, 10000.0f);
            GL11.glMatrixMode(GL11.GL_MODELVIEW);

            GL11.glDisable(GL11.GL_FOG);
            GL11.glColor4f(1.0f, 0.0f, 0.0f, 0.5f);
            GL11.glLineWidth(1.5f);

            for (Vec2D vec : chunks)
            {
                double x = vec.x() * 16 - RenderManager.renderPosX;
                double z = vec.y() * 16 - RenderManager.renderPosZ;

                if (remove.value() && (x * x + z * z) > removeDist.value() * removeDist.value())
                {
                    chunks.remove(vec);
                    continue;
                }

                Render3d.drawOutlinedBox(AxisAlignedBB.getBoundingBox(x, y.value() - RenderManager.renderPosY, z, x + 16, y.value() - RenderManager.renderPosY, z + 16));
            }

            GL11.glEnable(GL11.GL_FOG);
        });
    }

    @SubscribeEvent
    public void onWorldChange(WorldChangeEvent event)
    {
        chunks.clear();
    }

    private boolean isNewChunk(int last, int latest)
    {
        return (falling.value() && latest == 0 && (last == 12 || last == 13)) ||
                (liquids.value() && last == 0 && latest >= 8 && latest <= 11);
    }

    public static NewChunks instance()
    {
        return instance;
    }
}