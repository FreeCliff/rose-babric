package me.ht9.rose.feature.module.modules.exploit.newchunks;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PacketEvent;
import me.ht9.rose.event.events.RenderWorldPassEvent;
import me.ht9.rose.event.events.WorldChangeEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.util.world.Vec2D;
import me.ht9.rose.mixin.accessors.EntityRendererAccessor;
import me.ht9.rose.util.render.Render3d;
import net.minecraft.src.AxisAlignedBB;
import net.minecraft.src.Packet53BlockChange;
import net.minecraft.src.RenderManager;
import org.lwjgl.opengl.GL11;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@Description("Show new chunks (does have false positives) Taken from MEDMEX's mmod")
public final class NewChunks extends Module
{
    private static final NewChunks instance = new NewChunks();

    private final List<Vec2D> chunks = new CopyOnWriteArrayList<>();

    @Override
    public void onDisable()
    {
        this.chunks.clear();
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event)
    {
        if (!(event.packet() instanceof Packet53BlockChange packet)) return;

        if (packet.type == 9 || packet.type == 11)
        {
            int chunkX = packet.xPosition >> 4;
            int chunkZ = packet.zPosition >> 4;

            Vec2D chunkVec = new Vec2D(chunkX, chunkZ);
            for (Vec2D vec : this.chunks)
            {
                if (!vec.equals(chunkVec)) continue;
                return;
            }
            this.chunks.add(chunkVec);
        }
    }

    @SubscribeEvent
    public void onRender3d(RenderWorldPassEvent event)
    {
        for (Vec2D vec : this.chunks)
        {
            double dX = mc.thePlayer.posX - vec.x() * 16;
            double dZ = mc.thePlayer.posZ - vec.y() * 16;

            double distance = Math.sqrt(dX * dX + dZ * dZ);
            if (distance > 400)
            {
                this.chunks.remove(vec);
                continue;
            }

            int minX = (int) vec.x() * 16;
            int minZ = (int) vec.y() * 16;
            int maxX = minX + 16;
            int maxZ = minZ + 16;

            Render3d.render3d(() ->
            {
                double x = minX - RenderManager.renderPosX;
                double y = 0 - RenderManager.renderPosY;
                double z = minZ - RenderManager.renderPosZ;

                AxisAlignedBB bb = AxisAlignedBB.getBoundingBox(x, y, z, x - minX + maxX, y, z - minZ + maxZ);

                ((EntityRendererAccessor) mc.entityRenderer).invokeSetupCameraTransform(event.partialTicks(), 0);

                GL11.glColor4f(1.0f, 0.0f, 0.0f, 1.0f);
                Render3d.drawOutlinedBox(bb);
            });
        }
    }

    @SubscribeEvent
    public void onWorldChange(WorldChangeEvent event)
    {
        this.chunks.clear();
    }

    public static NewChunks instance()
    {
        return instance;
    }
}
