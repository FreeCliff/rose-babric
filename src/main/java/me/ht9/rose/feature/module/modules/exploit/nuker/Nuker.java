package me.ht9.rose.feature.module.modules.exploit.nuker;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PlayerBlockClickEvent;
import me.ht9.rose.event.events.TickEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.util.module.Timer;

import net.minecraft.src.Block;
import net.minecraft.src.Packet14BlockDig;

import java.util.ArrayList;
import java.util.Objects;

@Description(value = "Automatically mines blocks.")
public class Nuker extends Module
{
    private static final Nuker instance = new Nuker();

    private final Setting<Integer> nukerRadius = new Setting<>("Radius", 2, 5, 6);
    private final Setting<Integer> nukerDelay = new Setting<>("Delay", 1, 250, 1000);
    private final Setting<Boolean> excludeBlocksBelow = new Setting<>("ExcludeBlocksBelow", true);
    private final Setting<Boolean> yOnEnable = new Setting<>("YOnEnable", true, this.excludeBlocksBelow::value);
    private final ArrayList<Block> whitelistedBlocks = new ArrayList<>();
    private final Timer timer = new Timer();
    private int playerY;

    @SuppressWarnings("unused")
    @SubscribeEvent
    public void onBlockClicked(PlayerBlockClickEvent event)
    {
        int blockId = mc.theWorld.getBlockId(event.x(), event.y(), event.z());
        Block block = Block.blocksList[blockId];

        if (!this.whitelistedBlocks.contains(block))
        {
            this.whitelistedBlocks.add(block);
            mc.ingameGUI.addChatMessage("Added '" + block.getBlockName() + "' to the whitelist.");
        } else
        {
            mc.ingameGUI.addChatMessage("'" + block.getBlockName() + "' is already in the whitelist.");
        }
    }

    @Override
    public void onEnable()
    {
        if (this.yOnEnable.value() && this.excludeBlocksBelow.value())
        {
            this.playerY = (int) Math.floor(mc.thePlayer.posY);
        }
        this.timer.reset();
    }

    @SuppressWarnings("unused")
    @SubscribeEvent
    public void onTick(TickEvent event)
    {
        boolean shouldSelect = !mc.thePlayer.isDead;
        int range = this.nukerRadius.value();
        int playerX = (int) Math.floor(mc.thePlayer.posX);
        if (!this.yOnEnable.value())
        {
            this.playerY = (int) Math.floor(mc.thePlayer.posY);
        }
        int playerZ = (int) Math.floor(mc.thePlayer.posZ);

        ArrayList<Integer[]> positionsToMine = new ArrayList<>();

        for (int y = playerY + range; y >= playerY - range; y--)
        {
            for (int x = playerX - range; x <= playerX + range; x++)
            {
                for (int z = playerZ - range; z <= playerZ + range; z++)
                {
                    double distanceSq = (x - playerX) * (x - playerX) + (y - playerY) * (y - playerY) + (z - playerZ) * (z - playerZ);
                    if (distanceSq <= range * range)
                    {
                        if (this.excludeBlocksBelow.value() && (y < (playerY - 1)))
                        {
                            continue;
                        }

                        // Add valid block positions to the list
                        int blockId = mc.theWorld.getBlockId(x, y, z);
                        Block block = Block.blocksList[blockId];

                        if (shouldSelect)
                        {
                            for (Block blocks : whitelistedBlocks)
                            {
                                if (block != null && Objects.equals(blocks, block))
                                {
                                    positionsToMine.add(new Integer[]{x, y, z});
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        positionsToMine.sort((pos1, pos2) -> !Objects.equals(pos2[1], pos1[1]) ? Integer.compare(pos2[1], pos1[1]) : Integer.compare((pos2[0] - playerX) * (pos2[0] - playerX) + (pos2[1] - playerY) * (pos2[1] - playerY) + (pos2[2] - playerZ) * (pos2[2] - playerZ), (pos1[0] - playerX) * (pos1[0] - playerX) + (pos1[1] - playerY) * (pos1[1] - playerY) + (pos1[2] - playerZ) * (pos1[2] - playerZ)));

        for (Integer[] pos : positionsToMine)
        {
            int x = pos[0];
            int y = pos[1];
            int z = pos[2];

            if (this.timer.hasReached(nukerDelay.value()))
            {
                mc.getSendQueue().addToSendQueue(new Packet14BlockDig(0, x, y, z, 1));
                mc.getSendQueue().addToSendQueue(new Packet14BlockDig(2, x, y, z, 1));
                mc.playerController.sendPlaceBlock(
                        mc.thePlayer,
                        mc.theWorld,
                        mc.thePlayer.getHeldItem(),
                        x,
                        y,
                        z,
                        1
                );
                this.timer.reset();
            }

            return;
        }
    }

    public static Nuker instance()
    {
        return instance;
    }
}