package me.ht9.rose.feature.module.modules.exploit.nuker;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PlayerBlockClickEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.modules.exploit.instamine.Instamine;
import me.ht9.rose.feature.module.setting.Setting;
import me.ht9.rose.util.module.Timer;

import net.minecraft.src.Block;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

@Description(value = "Automatically mines blocks.")
public class Nuker extends Module
{
    private static final Nuker instance = new Nuker();

    private final Setting<Integer> nukerRadius = new Setting<>("Radius", 2, 5, 6);
    private final Setting<Integer> nukerDelay = new Setting<>("Delay", 0, 250, 1000);
    private final Setting<Boolean> excludeBlocksBelow = new Setting<>("ExcludeBlocksBelow", true);
    private final Setting<Boolean> yOnEnable = new Setting<>("YOnEnable", true, this.excludeBlocksBelow::value);
    private final ArrayList<Block> whitelistedBlocks = new ArrayList<>();
    private final Timer timer = new Timer();
    private int playerY;

    @SuppressWarnings("unused")
    @SubscribeEvent
    public void onBlockClicked(PlayerBlockClickEvent event)
    {
        int blockId = mc.theWorld.getBlockId(event.x(), event.y(), event.z());
        Block block = Block.blocksList[blockId];

        if (!this.whitelistedBlocks.contains(block))
        {
            this.whitelistedBlocks.add(block);
            mc.ingameGUI.addChatMessage("Added '" + block.getBlockName() + "' to the whitelist.");
        } else
        {
            mc.ingameGUI.addChatMessage("'" + block.getBlockName() + "' is already in the whitelist.");
        }
    }

    @Override
    public void onEnable()
    {
        if (this.yOnEnable.value() && this.excludeBlocksBelow.value())
        {
            this.playerY = (int) Math.floor(mc.thePlayer.posY);
        }
        this.timer.reset();
    }

    @SuppressWarnings("unused")
    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event)
    {
        boolean shouldSelect = !mc.thePlayer.isDead;
        int range = this.nukerRadius.value();
        int playerX = (int) Math.floor(mc.thePlayer.posX);
        if (!this.yOnEnable.value())
        {
            this.playerY = (int) Math.floor(mc.thePlayer.posY);
        }
        int playerZ = (int) Math.floor(mc.thePlayer.posZ);

        List<Integer[]> positionsToMine = new ArrayList<>();

        for (int y = playerY + range; y >= playerY - range; y--)
        {
            for (int x = playerX - range; x <= playerX + range; x++)
            {
                for (int z = playerZ - range; z <= playerZ + range; z++)
                {
                    double distanceSq = (x - playerX) * (x - playerX) + (y - playerY) * (y - playerY) + (z - playerZ) * (z - playerZ);
                    if (distanceSq <= range * range)
                    {
                        if (this.excludeBlocksBelow.value() && (y < (playerY - 1)))
                        {
                            continue;
                        }

                        // Add valid block positions to the list
                        int blockId = mc.theWorld.getBlockId(x, y, z);
                        Block block = Block.blocksList[blockId];

                        if (shouldSelect)
                        {
                            for (Block blocks : whitelistedBlocks)
                            {
                                if (block != null && Objects.equals(blocks, block))
                                {
                                    positionsToMine.add(new Integer[]{x, y, z});
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        positionsToMine.sort(Comparator.comparingDouble(value ->
        {
            double dX = value[0] + 0.5 - mc.thePlayer.posX;
            double dY = value[1] + 0.5 - mc.thePlayer.posY;
            double dZ = value[2] + 0.5 - mc.thePlayer.posZ;
            return dX * dX + dY * dY + dZ * dZ;
        }));

        for (Integer[] pos : positionsToMine)
        {
            int x = pos[0];
            int y = pos[1];
            int z = pos[2];

            double deltaX = x + 0.5 - mc.thePlayer.posX;
            double deltaY = y + 0.5 - mc.thePlayer.posY;
            double deltaZ = z + 0.5 - mc.thePlayer.posZ;
            double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

            float yaw = (float) (Math.atan2(deltaZ, deltaX) * (180 / Math.PI)) - 90;
            float pitch = (float) -(Math.atan2(deltaY, distance) * (180 / Math.PI));

            event.setYaw(yaw);
            event.setPitch(pitch);
            event.setModelRotations();

            if (this.timer.hasReached(nukerDelay.value(), true))
            {
                Instamine.instance().mineBlock(x, y, z, 0);
            }

            return;
        }
    }

    public static Nuker instance()
    {
        return instance;
    }
}