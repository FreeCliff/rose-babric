package me.ht9.rose.feature.module.modules.exploit.boattravel;

import me.ht9.rose.event.bus.annotation.SubscribeEvent;
import me.ht9.rose.event.events.PosRotUpdateEvent;
import me.ht9.rose.feature.module.Module;
import me.ht9.rose.feature.module.annotation.Description;
import me.ht9.rose.feature.module.setting.Setting;
import net.minecraft.src.EntityBoat;
import net.minecraft.src.Packet13PlayerLookMove;

@Description("Boat go brrr. Only works in multiplayer.")
public final class BoatTravel extends Module
{
    private static final BoatTravel instance = new BoatTravel();

    public final Setting<Mode> mode = new Setting<>("Mode", Mode.Automatic);

    public final Setting<Integer> xVelocity = new Setting<>("xVelocity", -1, 0, 1, () -> mode.value().equals(Mode.Automatic));
    public final Setting<Integer> zVelocity = new Setting<>("zVelocity", -1, 0, 1, () -> mode.value().equals(Mode.Automatic));

    public final Setting<Integer> speed = new Setting<>("Speed", 1, 1, 100);
    public final Setting<Integer> packetMultiplier = new Setting<>("PacketMult", 1, 1, 25);

    @SuppressWarnings("unused")
    @SubscribeEvent
    public void onUpdate(PosRotUpdateEvent event)
    {
        if (mc.thePlayer.ridingEntity == null) return;
        if (!(mc.thePlayer.ridingEntity instanceof EntityBoat)) return;
        if (!mc.isMultiplayerWorld()) return;

        double xVel = 0;
        double zVel = 0;

        if (mode.value().equals(Mode.Automatic))
        {
            xVel = xVelocity.value() * speed.value();
            zVel = zVelocity.value() * speed.value();
        }
        else if (mode.value().equals(Mode.Manual))
        {
            float yaw = event.yaw();
            float forward = mc.thePlayer.movementInput.moveForward;
            float strafe = mc.thePlayer.movementInput.moveStrafe;

            if (forward != 0.0F)
            {
                if (strafe > 0.0F)
                {
                    yaw += ((forward > 0.0F) ? -45 : 45);
                }
                else if (strafe < 0.0F)
                {
                    yaw += ((forward > 0.0F) ? 45 : -45);
                }
                strafe = 0.0F;
                if (forward > 0.0F)
                {
                    forward = 1.0F;
                }
                else if (forward < 0.0F)
                {
                    forward = -1.0F;
                }
            }
            if (strafe > 0.0F)
            {
                strafe = 1.0F;
            }
            else if (strafe < 0.0F)
            {
                strafe = -1.0F;
            }
            double mx = Math.cos(Math.toRadians((yaw + 90.0F)));
            double mz = Math.sin(Math.toRadians((yaw + 90.0F)));

            xVel = forward * speed.value() * mx + strafe * speed.value() * mz;
            zVel = forward * speed.value() * mz - strafe * speed.value() * mx;
        }

        for (int i = 0; i < packetMultiplier.value(); i++)
            mc.getSendQueue().addToSendQueue(new Packet13PlayerLookMove(xVel, -999, -999, zVel, mc.thePlayer.rotationYaw, mc.thePlayer.rotationPitch, false));
    }

    public static BoatTravel instance() {
        return instance;
    }

    public enum Mode
    {
        Manual,
        Automatic
    }
}
